#include "pch.h"
#include "Simple structures.h"
#include "Figures.h"

// CIRCLE //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Унаследованная функция отрисовки.
void Circle::print(Ar60_30 & ws)
{
	for (int y = get_loc().y - radius; y <= get_loc().y + radius; ++y)
	{
		for (int x = get_loc().x - radius; x <= get_loc().x + radius; ++x)
		{
			if (x >= 0 && x < 60 && y >= 0 && y < 30)
			{
				if ((x - get_loc().x)*(x - get_loc().x) + (y - get_loc().y)*(y - get_loc().y) <= radius * radius)
				{
					ws[y][x] = '0';
				}
			}
		}
	}
}


// RECTANGLE ////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Функция отрисовки прямоугольника, унаследованная от предка.
void My::Rectangle::print(Ar60_30 & ws)
{
	for (int y = get_loc().y; y != (get_loc().y + a); ++y) //Функция отрисовывает квадрат, перебирая по очереди содержимое рядов.
	{
		for (int x = get_loc().x; x != (get_loc().x + 1.6*a); ++x)//Внутренний цикл печатает символы ряда. Большая сторона  увеличена в 1.6 раза.
		{
			if (x >= 0 && x < 60 && y >= 0 && y < 30)//Условие, предостерегающее от выхода за границы массива.
			{
				ws[y][x] = '0';
			}
		}
	}
}


// RHOMB ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Rhomb::print(Ar60_30 & ws)//Определение унаследованной виртуальной функции.
{
	for (size_t y = (get_loc().y - diagonal / 2); y <= get_loc().y; ++y)
	{
		for (size_t x = (get_loc().x - diagonal / 2); x <= (get_loc().x + diagonal / 2); ++x)
		{
			if (x >= 0 && x < 60 && y >= 0 && y < 30)//Условие, предохраняющее от выхода за границы массива.
			{
				if (x >= get_loc().x - (y - (get_loc().y - diagonal / 2)) && x <= get_loc().x + (y - (get_loc().y - diagonal / 2)))
				{
					ws[y][x] = '0';
				}
			}
		}
	}

	for (size_t y = get_loc().y; y <= get_loc().y + diagonal / 2; ++y)
	{
		for (size_t x = get_loc().x - diagonal / 2; x <= get_loc().x + diagonal / 2; ++x)
		{
			if (x >= 0 && x < 60 && y >= 0 && y < 30)//Условие, предохраняющее от выхода за границы массива.
			{
				if (x >= get_loc().x - (get_loc().y + diagonal / 2 - y) && x <= get_loc().x + (get_loc().y + +diagonal / 2 - y))
				{
					ws[y][x] = '0';
				}
			}
		}
	}
}


// SQUARE ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Функция отрисовки квадрата, унаследованная от предка.
void Square::print(Ar60_30 & ws)
{

	for (int y = get_loc().y; y != (get_loc().y + a); ++y) //Функция отрисовывает квадрат, перебирая по очереди содержимое рядов.
	{
		for (int x = get_loc().x; x != (get_loc().x + a); ++x)//Внутренний цикл печатает символы ряда
		{
			if (x >= 0 && x < 60 && y >= 0 && y < 30)//Условие, предостерегающее от выхода за границы массива.
			{
				ws[y][x] = '0';
			}
		}
	}
}


// TRIANGLE ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Triangle::print(Ar60_30 & ws)//Унаследованная функция отрисовки треугольника.
{
	for (size_t y = get_loc().y; y <= point_A.y; ++y)
	{
		for (size_t x = get_loc().x; x <= point_B.x; ++x)
		{
			if (x >= 0 && x < 60 && y >= 0 && y < 30)//Условие, предохраняющее от выхода за границы массива.
			{
				if (x - get_loc().x < y - get_loc().y)
				{
					ws[y][x] = '0';
				}
			}
		}
	}
}
